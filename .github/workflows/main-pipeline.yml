name: Master CI/CD Pipeline

on:
  push:
    branches: [ "master", "dev" ]
  pull_request:
    branches: [ "master", "dev" ]

env:
  # Configuraci√≥n Global
  ACR_NAME: "ecommerceacrios25"
  RESOURCE_GROUP_BASE: "ecommerce-rg"
  AKS_CLUSTER_BASE: "ecommerce-aks"

# --- CAMBIO 1: Permisos de escritura a nivel global ---
permissions:
  contents: write
  pull-requests: write

jobs:
  # --- ETAPA 1: INTEGRACI√ìN CONTINUA (CI) ---
  ci-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with: 
          fetch-depth: 0 
  
      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: 'maven'

      # --- AN√ÅLISIS CON SONARCLOUD ---
      - name: Cache SonarCloud packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Build and Analyze (SonarQube)
        env:
          GITHUB_TOKEN: ${{ secrets.MY_PAT }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        # Ejecuta 'verify' para correr tests y luego el plugin de sonar
        # Si ya pusiste las propiedades en el pom.xml, este comando las leer√° autom√°ticamente
        run: mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=isabelaocampos_Proyecto-Final-Ingeniera-de-Software-V
      # -------------------------------------------
      # 2. Compilaci√≥n y Pruebas Unitarias
      - name: Build & Test
        run: mvn clean package -DskipTests

      # 3. Escaneo de Vulnerabilidades (Trivy FS)
      - name: Trivy Filesystem Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          trivy-config: trivy.yaml
          exit-code: '0'

      # 4. Versionado Sem√°ntico
      - name: Semantic Versioning
        id: semver
        uses: anothrNick/github-tag-action@1.67.0
        env:
          # --- CAMBIO 2: Usamos TU token personal (PAT) en lugar del default ---
          GITHUB_TOKEN: ${{ secrets.MY_PAT }} 
          # --------------------------------------------------------------------
          WITH_V: true
          DEFAULT_BUMP: patch

      # ... (despu√©s del paso 'Semantic Versioning')

      # 5. Generar Release Notes Autom√°ticos 
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        if: steps.semver.outputs.new_tag != '' # Solo si hay versi√≥n nueva
        with:
          tag_name: ${{ steps.semver.outputs.new_tag }}
          name: Release ${{ steps.semver.outputs.new_tag }}
          generate_release_notes: true 
          token: ${{ secrets.MY_PAT }} # Usa tu token personal

    outputs:
      new_version: ${{ steps.semver.outputs.new_tag }}

  # --- ETAPA 2: CONSTRUCCI√ìN Y PUBLICACI√ìN (Build & Push) ---
  build-push:
    needs: ci-check
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - uses: actions/checkout@v3
      
      - name: Login to ACR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push Docker Images
        run: |
          services="service-discovery cloud-config api-gateway product-service user-service order-service payment-service shipping-service favourite-service proxy-client"
          version="${{ needs.ci-check.outputs.new_version }}"
          
          for service in $services; do
            echo "üöÄ Procesando $service..."
            
            # Construir DENTRO de la carpeta para que Maven genere el target ah√≠
            cd $service
            mvn clean package -DskipTests
            
            docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/$service:$version .
            docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/$service:latest .
            
            docker push ${{ secrets.ACR_LOGIN_SERVER }}/$service:$version
            docker push ${{ secrets.ACR_LOGIN_SERVER }}/$service:latest
            
            cd ..
          done

  # --- ETAPA 3: DESPLIEGUE CONTINUO (CD) - DEV ---
  deploy-dev:
    needs: build-push
    runs-on: ubuntu-latest
    environment: 
      name: dev
      url: http://20.246.215.248:8080/actuator/health
    steps:
      - uses: actions/checkout@v3
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: "${{ env.RESOURCE_GROUP_BASE }}-dev"
          cluster-name: "${{ env.AKS_CLUSTER_BASE }}-dev"

      - name: Deploy to Kubernetes
        run: |
          # 1. Limpieza agresiva (Sin sed)
          echo "üßπ Borrando despliegues anteriores..."
          kubectl delete -f k8s/all-deployments.yaml --ignore-not-found=true || true
          
          echo "‚è≥ Esperando 20s..."
          sleep 20
          
          # 2. Desplegar la versi√≥n 'latest' (que ya est√° en el archivo YAML original)
          echo "üöÄ Desplegando nueva versi√≥n..."
          kubectl apply -f k8s/all-deployments.yaml
          
          # 3. Forzar reinicio para asegurar imagen fresca
          kubectl rollout restart deployment

      # --- NUEVO PASO: AUDITOR√çA DE CALIDAD ---
      - name: Verify Deployment Health
        run: |
          echo "üïµÔ∏è‚Äç‚ôÄÔ∏è Iniciando verificaci√≥n de salud de los microservicios..."
          
          # Lista de todos tus deployments (Aseg√∫rate de que los nombres coincidan con tu YAML)
          deployments="zipkin service-discovery cloud-config api-gateway product-service user-service order-service payment-service shipping-service favourite-service"
          
          for deploy in $deployments; do
            echo "‚è≥ Esperando a que $deploy est√© estabilizado..."
            
            # Espera hasta 3 minutos por servicio. Si falla, rompe el pipeline.
            if ! kubectl rollout status deployment/$deploy --timeout=300s; then
              echo "‚ùå ERROR CR√çTICO: El servicio $deploy no logr√≥ arrancar."
              
              # Muestra logs para que no tengas que entrar a Azure a ver qu√© pas√≥
              echo "--- LOGS DE LA MUERTE ($deploy) ---"
              kubectl logs -l app=$deploy --tail=50
              echo "-----------------------------------"
              
              exit 1 # Esto fuerza al pipeline a ponerse ROJO
            fi
          done
          
          echo "‚úÖ ¬°√âXITO! Todos los microservicios est√°n Running y listos."

  # --- ETAPA 4: PROMOCI√ìN A PROD (Manual) ---
  deploy-prod:
    needs: deploy-dev
    runs-on: ubuntu-latest
    environment: 
      name: prod
    if: github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v3
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context (PROD)
        uses: azure/aks-set-context@v3
        with:
          resource-group: "${{ env.RESOURCE_GROUP_BASE }}-prod"
          cluster-name: "${{ env.AKS_CLUSTER_BASE }}-prod"

      - name: Deploy to Kubernetes
        run: |
          # 1. Limpieza agresiva (Sin sed)
          echo "üßπ Borrando despliegues anteriores..."
          kubectl delete -f k8s/all-deployments.yaml --ignore-not-found=true || true
          
          echo "‚è≥ Esperando 20s..."
          sleep 20
          
          # 2. Desplegar la versi√≥n 'latest' (que ya est√° en el archivo YAML original)
          echo "üöÄ Desplegando nueva versi√≥n..."
          kubectl apply -f k8s/all-deployments.yaml
          
          # 3. Forzar reinicio para asegurar imagen fresca
          kubectl rollout restart deployment
      
      # --- NUEVO PASO: AUDITOR√çA DE CALIDAD ---
      - name: Verify Deployment Health
        run: |
          echo "üïµÔ∏è‚Äç‚ôÄÔ∏è Iniciando verificaci√≥n de salud de los microservicios..."
          
          # Lista de todos tus deployments (Aseg√∫rate de que los nombres coincidan con tu YAML)
          deployments="zipkin service-discovery cloud-config api-gateway product-service user-service order-service payment-service shipping-service favourite-service"
          
          for deploy in $deployments; do
            echo "‚è≥ Esperando a que $deploy est√© estabilizado..."
            
            # Espera hasta 3 minutos por servicio. Si falla, rompe el pipeline.
            if ! kubectl rollout status deployment/$deploy --timeout=300s; then
              echo "‚ùå ERROR CR√çTICO: El servicio $deploy no logr√≥ arrancar."
              
              # Muestra logs para que no tengas que entrar a Azure a ver qu√© pas√≥
              echo "--- LOGS DE LA MUERTE ($deploy) ---"
              kubectl logs -l app=$deploy --tail=50
              echo "-----------------------------------"
              
              exit 1 # Esto fuerza al pipeline a ponerse ROJO
            fi
          done
          
          echo "‚úÖ ¬°√âXITO! Todos los microservicios est√°n Running y listos."

  # --- ETAPA 5: NOTIFICACIONES DE FALLO ---
  notify-failure:
    needs: [ci-check, build-push, deploy-dev, deploy-prod]
    if: failure() 
    runs-on: ubuntu-latest
    steps:
      - name: Send Notification Email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          secure: true
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "üö® ALERTA: Fall√≥ el Despliegue en ${{ github.repository }}"
          to: "isabelaocampo08@gmail.com, valengonzatapiero@gmail.com"
          from: GitHub Actions Monitor
          body: |
            Hola equipo,
            El pipeline de CI/CD ha fallado. ‚ùå
            Revisar logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}